

/**constant $CONVERT_TAXONOMY = taxonomy('https://taxonomies.xbrl.us/standardized-statements/xusss.xsd')**/

constant $EP_XSD = 'https://eCollection.ferc.gov/taxonomy/form6/2025-04-01/form/form6/form-6_2025-04-01.xsd'

constant $CONVERT_TAXONOMY = taxonomy($EP_XSD)

constant $TAXONOMY_NAME = "FERC Form 6 2025-04-01"

constant $TAXONOMY_PREFIX = "ferc"

constant $FAMILY_NAME = "FERC Form 6"

constant $EXT_ROLE_NAMESPACE = "http://ferc.gov/form/2025-04-01/ferc"

/** DO NOT CHANGE BELOW HERE**/

constant $NAMESPACES = filter $CONVERT_TAXONOMY.namespaces where $item not in list("http://www.xbrl.org/2003/linkbase","http://xbrl.org/2008/generic", "http://www.w3.org/1999/xlink", "http://www.xbrl.org/2003/XLink", "http://xbrl.org/2005/xbrldt", "http://www.xbrl.org/dtr/type/2020-01-21")  and not $item.contains('sched-') and not $item.contains('roles/')

constant $CUBES = $CONVERT_TAXONOMY.cubes

constant $DIMENSIONS_EXPLICIT = filter $CONVERT_TAXONOMY.dimensions-explicit

constant $DIMENSIONS_TYPED = filter $CONVERT_TAXONOMY.dimensions-typed

constant $DIMENSIONS = filter $CONVERT_TAXONOMY.dimensions

constant $CONCEPT_DOMAIN = list(for $cube in $CUBES (filter $cube.primary-concepts.name where $item.local-name.contains('LineItems') returns $item).to-list.first)

constant $OLD_CONCEPTS = filter $CONVERT_TAXONOMY.concepts where not ($item.substitution.local-name == 'hypercubeItem' or $item.name.local-name == 'hypercubeItem' or $item.name in $DIMENSION_DOMAINS_SET)

constant $CONCEPTS = filter $CONVERT_TAXONOMY.concepts where  not ($item.substitution.local-name == 'dimensionItem' or $item.substitution.local-name == 'hypercubeItem' or $item.name.local-name == 'hypercubeItem' or $item.name.local-name == 'dimensionItem' or $item.data-type.name.local-name == 'domainItemType' or $item.is-abstract)

constant $ABSTRACTS = filter $CONVERT_TAXONOMY.concepts where $item.is-abstract and not ($item.substitution.local-name == 'dimensionItem' or $item.substitution.local-name == 'hypercubeItem' or $item.name.local-name == 'hypercubeItem' or $item.name.local-name == 'dimensionItem' or $item.data-type.name.local-name == 'domainItemType')

constant $MEMBERS = filter $CONVERT_TAXONOMY.concepts where $item.data-type.name.local-name == 'domainItemType'  and $item.name not in $DIMENSION_DOMAINS_SET

constant $NETWORKS_NO_LABELS = filter  $CONVERT_TAXONOMY.networks where not $item.role.uri.contains('http://www.xbrl.org/2003/role/link')

constant $NETWORKS_NO_DIMS = filter $NETWORKS_NO_LABELS where not ($item.arcrole.uri.contains('domain-member') or $item.arcrole.uri.contains('dimension-domain') or $item.arcrole.uri.contains('dimension-default') or $item.arcrole.uri.contains('all') or $item.arcrole.uri.contains('hypercube-dimension'))

constant $COLLAPSED_NETWORKS  = ((filter $NETWORKS_NO_LABELS returns list($item.role.uri, $item.role.description)).to-set).to-list.sort("asc")

constant $EXT_ENUMS = filter $CONVERT_TAXONOMY.concepts where $item.attribute(enum2:linkrole) != none

constant $EXT_ENUMS_SET = (filter $EXT_ENUMS returns list($item.attribute(enum2:domain).to-qname, $item.attribute(enum2:linkrole))).to-set


                            
constant $REF_NAME_A = dict(for $count in range($OLD_CONCEPTS.count)
                                $ConceptsList = $OLD_CONCEPTS.to-list
                                $concept = $ConceptsList[$count]
                                list($concept,$count)
)


constant $REFERENCES = list(for $concept in $OLD_CONCEPTS
                            for $ref_count in range($concept.all-references.count)
                            $ref_list = $concept.all-references.to-list
                            dict(list("relatedNames",list(if $LOOKUP_CHANGED_ELEMENTS[$concept.name] == none $concept.name else $LOOKUP_CHANGED_ELEMENTS[$concept.name])),
                            list("referenceType",qname(if $ref_list[$ref_count].role.uri in $EXT_REF_TYPES $EXT_ROLE_NAMESPACE else "https://xbrl.org/2025" , $ref_list[$ref_count].role.uri.split('\/').last)),
                            list("name", qname($CONVERT_TAXONOMY.entry-point-namespace, "R_" + string($REF_NAME_A[$concept]) + "_" + string($ref_count))),
                            list("properties",list(
                                  for $partItem in  $ref_list[$ref_count].parts
                                              dict(
                                                list("property", $partItem.name.clark),
                                                list("value", $partItem.part-value)
                                                )
                                              )
                                  )
                                )
                  )

constant $EXT_TYPES = filter $OLD_CONCEPTS where $item.data-type.name.namespace-uri not in list("http://www.xbrl.org/dtr/type/2022-03-31", "http://www.xbrl.org/dtr/type/non-numeric", "http://www.xbrl.org/dtr/type/numeric", "http://www.xbrl.org/2003/instance", "http://www.w3.org/2001/XMLSchema") returns list($item.data-type, $item.base-type)


constant $TYPES = list("dataTypes",list(for $type in $EXT_TYPES
    dict(
        list("name", qname($type[1].name.namespace-uri, $type[1].name.local-name)),
        list("baseType", if $BASE_TYPES[$type[2].name] == none $type[2].name else $BASE_TYPES[$type[2].name]),
        if $type[1].enumerations.length > 0 list("enumeration", $type[1].enumerations.to-list) else list()
        )
    )
)

constant $EXT_REF_SET_OF_TYPES = sum(filter $OLD_CONCEPTS.all-references returns $item)

constant $EXT_REF_TYPES = filter $EXT_REF_SET_OF_TYPES.role.uri where not $item.contains("http://www.xbrl.org/2003/role") returns $item

constant $REF_TYPES = list("referenceTypes",list(for $type in $EXT_REF_TYPES
    dict(
        list("name", qname($EXT_ROLE_NAMESPACE, $type.split('\/').last)),
        list("uri", $type),
        )
    )
)

constant $EXT_LAB_SET_OF_TYPES = sum(filter $OLD_CONCEPTS.all-labels returns $item)

constant $EXT_LAB_TYPES = filter $EXT_LAB_SET_OF_TYPES.role.uri where not $item.contains("http://www.xbrl.org/2003/role") returns $item

constant $LAB_TYPES = list("labelTypes",list(for $type in $EXT_LAB_TYPES
    dict(
        list("name", qname($EXT_ROLE_NAMESPACE, $type.split('\/').last)),
        list("uri", $type),
        )
    )
)

constant $EXT_RELATIONSHIPS = filter $NETWORKS_NO_LABELS where not $item.arcrole.uri.contains('xbrl.org') returns $item.arcrole.uri

constant $RELATIONSHIP_TYPES = list("relationshipTypes",list(for $relationship in $EXT_RELATIONSHIPS
    dict(
        list("name", qname($EXT_ROLE_NAMESPACE, $relationship.split('\/').last)),
        list("uri", $relationship),
        list("cycles", 'none')
        )
    )
)

constant $NETWORKS = list("networks",list(for $network in  $NETWORKS_NO_DIMS
          dict(
              list("name", qname($CONVERT_TAXONOMY.entry-point-namespace,$network.role.uri.split('\/').last + "_" + $network.arcrole.uri.split('\/').last + "_Network")),
              list("relationshipTypeName",qname(if $network.arcrole.uri.contains('xbrl.org') "https://xbrl.org/2025" else $EXT_ROLE_NAMESPACE , $network.arcrole.uri.split('\/').last)),
              list("roots",list(for $root in $network.roots $root.name )),
              list("relationships",list(for $relationship in filter $network.relationships 
              /** This replaces the domains and cubes **/
                    $source = if $relationship.source.name not in $LOOKUP_CUBE and $relationship.source.name not in $DIMENSION_DOMAINS_SET
                                      $relationship.source.name 
                                else if $relationship.source.name in $LOOKUP_CUBE  
                                          ($CUBE_MAP[list($relationship.source.name,$network.role.uri)][1])
                                     else 
                                              ($DIMENSION_DOMAINS_DICT[list($relationship.source.name,$network.role.uri)][1]);
                      
                      $target = if $relationship.target.name not in $LOOKUP_CUBE and $relationship.target.name not in $DIMENSION_DOMAINS_SET
                                      $relationship.target.name 
                                else if $relationship.target.name in $LOOKUP_CUBE  
                                          ($CUBE_MAP[list($relationship.target.name,$network.role.uri)][1])
                                     else 
                                           ($DIMENSION_DOMAINS_DICT[list($relationship.target.name,$network.role.uri)][1]);
                  dict(
                      list("source", $source),                 
                      list("target", $target),
                      list("order",$relationship.order),
                      if $relationship.weight != none list("weight",$relationship.weight) else skip,
                      if $relationship.preferred-label != none list("preferredLabel",qname($relationship.target.name.namespace-uri,$relationship.preferred-label.split('\/').last)) else skip,
                      )
                  )
              )
          )
        )
      )

constant $CUBE_MAP = dict(for $cube in $CUBES
                          $newCubeName = qname($cube.cube-concept.name.namespace-uri,$cube.cube-concept.name.local-name + "_" + $cube.drs-role.uri.split('\/').last + "_Cube")
                          list(list($cube.cube-concept.name,$cube.drs-role.uri),
                          list(
                                $newCubeName,
                                $cube.cube-concept.name
                                    ))
                          )

constant $DIMENSION_DOMAINS_DICT = dict(for $dimension in $DIMENSIONS
      if $dimension.dimension-type == 'explicit'
         $default_domain = $dimension.default.name;
         $new_domain_concept = qname($dimension.default.name.namespace-uri,$dimension.default.name.local-name + "_" + $dimension.cube.drs-role.uri.split('\/').last + "_DDomain");
          list(list($default_domain, $dimension.cube.drs-role.uri),
              list(
                  $new_domain_concept, 
                  $default_domain)
              )
      else skip
        )

constant $DIMENSION_DOMAINS_SET = set(for $dimension in $DIMENSIONS
                                          if $dimension.dimension-type == 'explicit'
                                            $dimension.default.name
                                          else skip
                                            )

constant $DIMENSION_DOMAINS = list(for $dimension in $DIMENSIONS
      if $dimension.dimension-type == 'explicit'
         $default_domain = $dimension.default.name;
         $new_domain_concept = qname($dimension.default.name.namespace-uri,$dimension.default.name.local-name + "_" + $dimension.cube.drs-role.uri.split('\/').last + "_DDomain");
          dict(
              /**list("networkURI",$dimension.cube.drs-role.uri),**/
              list("name",$new_domain_concept),
              list("relationships",list(for $relationship in navigate domain-member descendants from $default_domain role $dimension.cube.drs-role taxonomy $CONVERT_TAXONOMY  returns list (source-name, target-name, order)
                  dict(list("source",if $relationship[1] == $default_domain $new_domain_concept else $relationship[1]),
                      list("target",if $relationship[2] == $default_domain $new_domain_concept else $relationship[2]),
                      list("order",$relationship[3].number)
                      )
                    ) 
                  )
              )
      else skip
        )

constant $PRIMARY_DOMAINS = list(for $cube in $CUBES
      $p_domain_concept = (navigate all parents from $cube.cube-concept.name taxonomy $CONVERT_TAXONOMY  returns target-name).to-list;
      $new_domain_concept = qname($cube.cube-concept.name.namespace-uri,$cube.cube-concept.name.local-name + "_" + $cube.drs-role.uri.split('\/').last + "_PDomain")
      dict(
          list("name", $new_domain_concept),
          list("relationships",list(for $relationship in navigate domain-member descendants from $p_domain_concept role $cube.drs-role taxonomy $CONVERT_TAXONOMY  returns list (source-name, target-name, order)
              dict(list("source",if $relationship[1] == $p_domain_concept[1] $new_domain_concept else $relationship[1]),
                  list("target",if $relationship[2] == $p_domain_concept[1] $new_domain_concept else $relationship[2]),
                  list("order",$relationship[3].number)
                  )
                ) 
              ) 
          )
        )

constant $EXTENUM_DOMAINS = list(for $enum in $EXT_ENUMS_SET
      dict(
          list("domainName",$enum[1].local-name + "_" + $enum[2].split('\/').last + "_EDomain"),
          list("relationships",list(for $relationship in navigate domain-member descendants from ($enum[1]) role $enum[2] taxonomy $CONVERT_TAXONOMY  returns list (source-name, target-name, order)
              dict(list("source",$relationship[1]),
                  list("target",$relationship[2]),
                  list("order",$relationship[3].number)
                  )
                ) 
              ) 
          )
        )

constant $LOOKUP_CHANGED_ELEMENTS = dict(for $cube in $CUBES
                      $cube_name = list($cube, "cube")
                      $d_name = list($cube, "conceptDomain")
                      for $e_name in list($cube_name , $d_name)
                      list($e_name[1].cube-concept.name.local-name + "_" + $cube.drs-role.uri.split('\/').last, $e_name[1].cube-concept.name.clark + "_" + $cube.drs-role.uri.split('\/').last + "_" + $e_name[2])
                      )

constant $LOOKUP_CUBE = set(for $cube in $CUBES
                          $cube.cube-concept.name
                          )



constant $CUBE_LABELS = list(for $cube in $CUBES
                                $newCubeName = qname($cube.cube-concept.name.namespace-uri,$cube.cube-concept.name.local-name + "_" + $cube.drs-role.uri.split('\/').last + "_Cube")
                                for $label in $cube.cube-concept.all-labels
                                  dict(list("relatedName", $newCubeName),
                                      list("language",$label.lang),
                                            list("value",$label.text),
                                            list("labelType",if $label.role.uri in $BASE_LABELS.keys $BASE_LABELS[$label.role.uri] else qname($cube.cube-concept.name.namespace-uri, $label.role.uri.split('\/').last))
                                          )      
                          )

constant $DIM_DOMAIN_LABELS = list(for $dimension in $DIMENSIONS
                              if $dimension.dimension-type == 'explicit'
                                $default_domain = $dimension.default;
                                $new_domain_concept = qname($dimension.default.name.namespace-uri,$dimension.default.name.local-name + "_" + $dimension.cube.drs-role.uri.split('\/').last + "_DDomain");
                                  for $label in $default_domain.all-labels
                                  dict(list("relatedName", $new_domain_concept),
                                      list("language",$label.lang),
                                            list("value",$label.text),
                                            list("labelType",if $label.role.uri in $BASE_LABELS.keys $BASE_LABELS[$label.role.uri] else qname($dimension.default.name.namespace-uri, $label.role.uri.split('\/').last))
                                          )  
                              else skip
                                )

constant $PRIM_DOMAIN_LABELS = list(for $cube in $CUBES
                                  $p_domain_concept = (navigate all parents from $cube.cube-concept.name taxonomy $CONVERT_TAXONOMY  returns target).to-list;
                                  $new_domain_concept = qname($cube.cube-concept.name.namespace-uri,$cube.cube-concept.name.local-name + "_" + $cube.drs-role.uri.split('\/').last + "_PDomain")
                                  for $label in $p_domain_concept[1].all-labels
                                  dict(list("relatedName", $new_domain_concept),
                                      list("language",$label.lang),
                                            list("value",$label.text),
                                            list("labelType",if $label.role.uri in $BASE_LABELS.keys $BASE_LABELS[$label.role.uri] else qname($cube.cube-concept.name.namespace-uri, $label.role.uri.split('\/').last))
                                          )  
                                )


constant $BASE_TYPES = dict(
    list(xbrli:decimalItemType, "xs:decimal"),
    list(xbrli:floatItemType,"xs:float"),
    list(xbrli:doubleItemType,"xs:double"),
    list(xbrli:integerItemType,"xs:integer"),
    list(xbrli:nonPositiveIntegerItemType,"xs:nonPositiveInteger"),
    list(xbrli:negativeIntegerItemType,"xs:negativeInteger"),
    list(xbrli:longItemType,"xs:long"),
    list(xbrli:intItemType,"xs:int"),
    list(xbrli:shortItemType,"xs:short"),
    list(xbrli:byteItemType,"xs:byte"),
    list(xbrli:nonNegativeIntegerItemType,"xs:nonNegativeInteger"),
    list(xbrli:unsignedLongItemType,"xs:unsignedLong"),
    list(xbrli:unsignedIntItemType,"xs:unsignedInt"),
    list(xbrli:unsignedShortItemType,"xs:unsignedShort"),
    list(xbrli:unsignedByteItemType,"xs:unsignedByte"),
    list(xbrli:positiveIntegerItemType,"xs:positiveInteger"),
    list(xbrli:monetaryItemType,"xbrli:monetary"),
    list(xbrli:sharesItemType,"xbrli:shares"),
    list(xbrli:pureItemType,"xbrli:pure"),
    list(xbrli:stringItemType,"xs:string"),
    list(xbrli:booleanItemType,"xs:Boolean"),
    list(xbrli:hexBinaryItemType,"xs:hexBinary"),
    list(xbrli:base64BinaryItemType,"xs:base64Binary"),
    list(xbrli:anyURIItemType,"xs:anyURI"),
    list(xbrli:QNameItemType,"xs:QName"),
    list(xbrli:durationItemType,"xs:duration"),
    list(xbrli:dateTimeItemType,"xbrli:dateUnion"),
    list(xbrli:timeItemType,"xs:time"),
    list(xbrli:dateItemType,"xs:date"),
    list(xbrli:gYearMonthItemType,"xs:gYearMonth"),
    list(xbrli:gYearItemType,"xs:gYear"),
    list(xbrli:gMonthDayItemType,"xs:gMonthDay"),
    list(xbrli:gDayItemType,"xs:gDay"),
    list(xbrli:gMonthItemType,"xs:gMonth"),
    list(xbrli:normalizedStringItemType,"xs:normalizedString"),
    list(xbrli:tokenItemType,"xs:token"),
    list(xbrli:languageItemType,"xs:language"),
    list(xbrli:NameItemType,"xs:Name"),
    list(xbrli:NCNameItemType,"xs:NCName"),
    list(num:perShareItemType,"xbrli:perShare"),
    list(num:percentItemType,"xbrli:percent"),
    list(nonnum:textBlockItemType,"xbrli:textBlock"),
    list(num:volumeItemType,"xbrli:volume"),
    list(num:lengthItemType,"xbrli:length"),
    list(num:weightItemType,"xbrli:weight"),
    list(num:energyItemType,"xbrli:energy"),

)

constant $BASE_LABELS = dict(
    list("http://www.xbrl.org/2003/role/commentaryGuidance","xbrl:commentaryGuidance"),
    list("http://www.xbrl.org/2009/role/commonPracticeRef","xbrl:commonPracticeRef"),
    list("http://www.xbrl.org/2003/role/definitionGuidance","xbrl:definitionGuidance"),
    list("http://www.xbrl.org/2009/role/deprecatedDateLabel","xbrl:deprecatedDateLabel"),
    list("http://www.xbrl.org/2009/role/deprecatedLabel","xbrl:deprecatedLabel"),
    list("http://www.xbrl.org/2003/role/disclosureGuidance","xbrl:disclosureGuidance"),
    list("http://www.xbrl.org/2003/role/documentation","xbrl:documentation"),
    list("http://www.xbrl.org/2003/role/exampleGuidance","xbrl:exampleGuidance"),
    list("http://www.xbrl.org/2003/role/label","xbrl:label"),
    list("http://www.xbrl.org/2003/role/measurementGuidance","xbrl:measurementGuidance"),
    list("http://xbrl.us/us-gaap/role/label/negated","xbrl:negated"),
    list("http://www.xbrl.org/2009/role/negatedLabel","xbrl:negatedLabel"),
    list("http://www.xbrl.org/2009/role/negatedNetLabel","xbrl:negatedNetLabel"),
    list("http://xbrl.us/us-gaap/role/label/negatedPeriodEnd","xbrl:negatedPeriodEnd"),
    list("http://www.xbrl.org/2009/role/negatedPeriodEndLabel","xbrl:negatedPeriodEndLabel"),
    list("http://xbrl.us/us-gaap/role/label/negatedPeriodStart","xbrl:negatedPeriodStart"),
    list("http://www.xbrl.org/2009/role/negatedPeriodStartLabel","xbrl:negatedPeriodStartLabel"),
    list("http://www.xbrl.org/2009/role/negatedTerseLabel","xbrl:negatedTerseLabel"),
    list("http://xbrl.us/us-gaap/role/label/negatedTotal","xbrl:negatedTotal"),
    list("http://www.xbrl.org/2009/role/negatedTotalLabel","xbrl:negatedTotalLabel"),
    list("http://www.xbrl.org/2009/role/negativeLabel","xbrl:negativeLabel"),
    list("http://www.xbrl.org/2009/role/negativePeriodEndLabel","xbrl:negativePeriodEndLabel"),
    list("http://www.xbrl.org/2009/role/negativePeriodEndTotalLabel","xbrl:negativePeriodEndTotalLabel"),
    list("http://www.xbrl.org/2003/role/negativePeriodStartLabel","xbrl:negativePeriodStartLabel"),
    list("http://www.xbrl.org/2009/role/negativePeriodStartTotalLabel","xbrl:negativePeriodStartTotalLabel"),
    list("http://www.xbrl.org/2009/role/negativeTerseLabel","xbrl:negativeTerseLabel"),
    list("http://www.xbrl.org/2009/role/negativeVerboseLabel","xbrl:negativeVerboseLabel"),
    list("http://www.xbrl.org/2009/role/netLabel","xbrl:netLabel"),
    list("http://www.xbrl.org/2003/role/periodEndLabel","xbrl:periodEndLabel"),
    list("http://www.xbrl.org/2003/role/periodStartLabel","xbrl:periodStartLabel"),
    list("http://www.xbrl.org/2003/role/presentationGuidance","xbrl:presentationGuidance"),
    list("http://www.xbrl.org/2003/role/positiveLabel","xbrl:positiveLabel"),
    list("http://www.xbrl.org/2009/role/positivePeriodEndLabel","xbrl:positivePeriodEndLabel"),
    list("http://www.xbrl.org/2009/role/positivePeriodEndTotalLabel","xbrl:positivePeriodEndTotalLabel"),
    list("http://www.xbrl.org/2009/role/positivePeriodStartLabel","xbrl:positivePeriodStartLabel"),
    list("http://www.xbrl.org/2009/role/positivePeriodStartTotalLabel","xbrl:positivePeriodStartTotalLabel"),
    list("http://www.xbrl.org/2003/role/positiveTerseLabel","xbrl:positiveTerseLabel"),
    list("http://www.xbrl.org/2003/role/positiveVerboseLabel","xbrl:positiveVerboseLabel"),
    list("http://www.xbrl.org/2006/role/restatedLabel","xbrl:restatedLabel"),
    list("http://www.xbrl.org/2025/role/symbolLabel","xbrl:symbolLabel"),
    list("http://www.xbrl.org/2003/role/terseLabel","xbrl:terseLabel"),
    list("http://www.xbrl.org/2003/role/totalLabel","xbrl:totalLabel"),
    list("http://www.xbrl.org/2003/role/verboseLabel","xbrl:verboseLabel"),
    list("http://www.xbrl.org/2003/role/zeroLabel","xbrl:zeroLabel"),
    list("http://www.xbrl.org/2003/role/zeroTerseLabel","xbrl:zeroTerseLabel"),
    list("http://www.xbrl.org/2003/role/zeroVerboseLabel","xbrl:zeroVerboseLabel")
    )


constant $namespaceDict = dict(
    list("http://fasb.org/us-gaap/2024", "us-gaap"),
    list("http://fasb.org/srt/2024", "srt"),
    list("http://www.xbrl.org/2003/iso4217", "iso4217"),
    list("http://xbrl.sec.gov/dei/2024", "dei"),
    list("http://xbrl.sec.gov/country/2024", "country"),
    list("http://www.xbrl.org/2003/instance", "xbrli"),
    list("http://xbrl.sec.gov/exch/2024", "exch"),
    list("http://xbrl.sec.gov/currency/2024", "currency"),
    list("http://xbrl.sec.gov/stpr/2024", "stpr"),
    list("http://xbrl.sec.gov/sic/2024", "sic"),
    list("http://xbrl.sec.gov/naics/2024", "naics"),
    list("http://www.xbrl.org/dtr/type/non-numeric", "nonnum"),
    list("http://www.xbrl.org/dtr/type/numeric", "num"),
    list("http://fasb.org/us-types/2024", "us-types"),
    list("http://fasb.org/srt-types/2024", "srt-types"),
    list("http://fasb.org/dqcrules/2024", "dqcrules"),
    list("http://fasb.org/dqcrules-0015/2024", "dqcrules15"),
    list("http://www.xbrl.org/dtr/type/2022-03-31", "dtr-types"),
    list("http://xbrl.org/2020/extensible-enumerations-2.0", "enum2"),
    list("http://xbrl.org/2005/xbrldt", "xbrldt"),
    list("http://xbrl.sec.gov/ecd/2024", "ecd"),
    list("http://fasb.org/us-gaap-ebp/2024", "us-gaap-ebp"),
    list("http://fasb.org/us-gaap-metaModel/2025", "us-gaap-metaModel"),
    list("http://www.w3.org/2001/XMLSchema", "xs"),
    list("https://taxonomies.xbrl.us/standardized-statements", "xuss"),
    list("http://ferc.gov/form/2025-04-01/ferc", "ferc"),
    list("http://www.ferc.gov/form/parts", "ferc-parts"),
    list("http://ferc.gov/form/2025-04-01/types", "ferc-types"),
    list("http://ferc.gov/form/2025-04-01/ferc-form-60", "ferc-form-60"),
    list("http://ferc.gov/form/2025-04-01/ferc-form-6", "ferc-form-6"),
)


output refs

$DIMENSION_DOMAINS_DICT

output test_taxonomy

dict(
    list("documentInfo",dict(
      list("documentType","https://xbrl.org/PWD/2025-01-31/oim"),
      list("namespaces",list(for $namespace in $NAMESPACES
        if $namespace not in list("http://www.xbrl.org/dtr/type/numeric", "http://www.xbrl.org/dtr/type/non-numeric","http://www.xbrl.org/2003/instance")
          dict(list("prefix",$namespaceDict[$namespace]),
              list("uri",$namespace)
              )
        else skip
        )
        + list(
          dict(list("prefix","xbrl"), 
              list("uri","https://xbrl.org/2025")
              )
        )
        + list(
          dict(list("prefix","xbrli"), 
              list("uri","http://www.xbrl.org/2025/instance")
              )
        )
      )
      )
    ),
    list("taxonomy",dict(
      list("name",$TAXONOMY_NAME),
      list("frameworkName",$FAMILY_NAME),
      list("canonicalForm",'true'),
      list("abstracts",list(for $abstract in  $ABSTRACTS
        dict(
            list("name",$abstract.name)
        )
      )
      ),
      list("members",list(for $member in  $MEMBERS
        dict(
            list("name",$member.name)
        )
      )
      ),
      list("concepts", list(for $concept in $CONCEPTS
          dict(
            list("name",$concept.name),
            list("nillable",true),
            list("periodType",$concept.period-type),
            if $concept.balance != none
                list("properties",list(
                  dict(list("property","xbrl:balance"),
                        list("value",$concept.balance)
                  )
                )
                )
            else
                list(),
            list("dataType",if $BASE_TYPES[$concept.data-type.name] == none $concept.data-type.name else $BASE_TYPES[$concept.data-type.name]),
            if $concept.attribute(enum2:linkrole) != none
              list("enumerationValues",
                dict(
                    list("headUsable",$concept.attribute(enum2:headUsable)),
                    list("domainName",$concept.attribute(enum2:domain).to-qname.local-name + "_Object")
                    )
            )
            else list()
            )
          )
        ),
        list("groups",list(for $role in $COLLAPSED_NETWORKS
          dict(list("name",qname($CONVERT_TAXONOMY.entry-point-namespace, $role.first.split('\/').last + "Group")),
              list("groupURI",$role.first)
          )
        )
      ),
      list("groupContents",list(
          for $role in $COLLAPSED_NETWORKS
            dict(
                list("groupName",qname($CONVERT_TAXONOMY.entry-point-namespace, $role.first.split('\/').last + "Group")),
                list("relatedNames", list(for $network in filter $NETWORKS_NO_DIMS where ($item.arcrole.uri.contains('parent-child') or $item.arcrole.uri.contains('summation-item')) and $item.role.uri == $role.first
                                          qname($CONVERT_TAXONOMY.entry-point-namespace, $network.role.uri.split('\/').last + "_" + $network.arcrole.uri.split('\/').last + "_Network")
                                          )
                            )
                )
          )
            
      ),
      list("dimensions",list(for $dimension in $DIMENSIONS
        dict(list("name",$dimension.concept.name),
            if $dimension.dimension-type == 'typed'
                list("domainDataType","xs:token")  // TODO Need a function to return the type of a typed dimension
            else
                list(),
        )
      )
      ),
      list("labels",list(for $concept in $OLD_CONCEPTS
                            for $label in $concept.all-labels
          dict(list("relatedName",$concept.name),
              list("language",$label.lang),
                    list("value",$label.text),
                    list("labelType",if $label.role.uri in $BASE_LABELS.keys $BASE_LABELS[$label.role.uri] else qname($concept.name.namespace-uri, $label.role.uri.split('\/').last))
                  )
          ) + $CUBE_LABELS + $DIM_DOMAIN_LABELS + $PRIM_DOMAIN_LABELS 
      ),
      list("references",$REFERENCES
      ),
      $NETWORKS,
      list("cubes",list(for $cube in $CUBES
          dict(list("name", qname($cube.cube-concept.name.namespace-uri,$cube.cube-concept.name.local-name + "_" + $cube.drs-role.uri.split('\/').last + "_Cube")),
              list("cubeType","xbrl:reportCube"),
              list("cubeDimensions",list(for $dimension in filter $cube.dimensions 
                  dict(list("dimensionName",$dimension.concept.name),
                      if $dimension.dimension-type == "explicit" list("domainName",qname($dimension.default.name.namespace-uri, $dimension.default.name.local-name + "_" + $cube.drs-role.uri.split('\/').last + "_DDomain")) else list(),
                      if $dimension.dimension-type == "explicit" list("allowDomainFacts",true) else list("allowDomainFacts",false)
                      )
                  ) + list(dict(list("dimensionName","xbrl:concept"),
                      list("domainName",qname($cube.cube-concept.name.namespace-uri, $cube.cube-concept.name.local-name + "_" + $cube.drs-role.uri.split('\/').last + "_PDomain"))
                      )
                  ) + list(dict(list("dimensionName","xbrl:period"),
                      list("allowDomainFacts",true)
                      )
                  ) + list(dict(list("dimensionName","xbrl:unit"),
                      list("allowDomainFacts",true)
                      )
                  ) + list(dict(list("dimensionName","xbrl:entity")
                      )
                  )
              ),
              list("cubeNetworks",list(for $network in filter $NETWORKS_NO_DIMS where ($item.arcrole.uri.contains('parent-child') or $item.arcrole.uri.contains('summation-item')) and $item.role.uri == $cube.drs-role.uri
                  qname($CONVERT_TAXONOMY.entry-point-namespace,$network.role.uri.split('\/').last + "_" + $network.arcrole.uri.split('\/').last + "_Network")
                  )
              )
          )
        )
      ),
      $TYPES,
      $REF_TYPES,
      $LAB_TYPES,
      $RELATIONSHIP_TYPES,
      list("domains", $DIMENSION_DOMAINS + $PRIMARY_DOMAINS + $EXTENUM_DOMAINS
      )

    )
    )
)

file-location 'form60.json'
file-content $rule-value.to-json
